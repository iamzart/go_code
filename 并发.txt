并发

管道
*创建： 用内置函数make，两个参数，第一个管道的类型，第二个缓冲大小
用完一个管道后要关闭管道
ch <- 写入数据
<- 读取数据

无缓冲
对于无缓冲管道而言，因为缓冲区容量为0，所以不会临时存放任何数据，因为无缓冲管道无法存放数据，所以在向管道写入数据时必须立刻有其他协程来读取数据，否则就会阻塞等待


主死从随

sync
/*waitgroup
可以等着，让主协程等着
add加（协程数），done-1，wait等着

/*mytex--互斥锁
加锁为了让两个协程不冲突
lock()加锁
unlock解锁，分别加在执行语句的前后


管道便利：
用for range
在遍历前要关闭管道

默认情况下，管道是双向的（可读可写，可以声明为只读，只写

声明的时候 给chan后边加上《-就是只写

管道是一个引用类型，如果不加读取，打印的就是地址

如果 goroutine 需要用到外部变量，就传参。
如果 goroutine 内部


使用完一个管道一定要关闭

waitgroup我明白了，就是他是一个结构体，并且作为参数被传参时，要传指针类型，它里面有三个函数，Add记录一共有多少个协程（一共执行多少次），Done每次都减一，知道把Add减空，Wait就会不等了

value有两个参数，key和val，可以根据key去找val

context是个结构体，这种类型的参数就是。background
context.Background() 生成一个最基础的 Context，通常用作根 context

withdeadline参数是一个文，一个具体时间
withtimeout参数是一个文，一个时间段

ctx.Done就是超时的意思

上下文也是一种资源，就跟内存分配后不会受会造成内存泄漏一样，如果创建了不取消，一样会造成上下文泄露

case <-ctx.Done() 的 <- 其实是在监听 Done() 这个 chan struct{}，一旦 context 被取消，Done() 返回的通道就会关闭，从而触发 select 语句的 case。


select
要想一直监测管道，可以配合 for 循环使用，不然的话，找到一条执行完就推出了


lock.Lock() 加在修改 count 之前，保证其他 Goroutine 不能同时修改 count。
lock.Unlock() 加在修改 count 之后，解锁让其他 Goroutine 继续执行

关键点：锁应该尽可能短，避免阻塞其他 Goroutine

在 Go 里，如果多个 Goroutine 需要竞争 同一把锁（sync.Mutex），那么：

只有 一个 Goroutine 能获得锁。
其他 Goroutine 必须等它释放锁后才能继续执行。
如果持锁的 Goroutine 在 Sleep()，其他 Goroutine 只能干等着，不能执行，就像排队买票一样，一个人没买完，后面的人都只能等。
这样一来，Goroutine 就 一个接一个执行，相当于 失去了并发能力，变成了串行执行。


/*sync*/
sync下的Once，用于只执行一次的程序，比如初始化只需一次，就用snyc的Once的Do方法，它的参数是一个函数


Pool
sync.Pool 的设计目的是用于存储临时对象以便后续的复用，是一个临时的并发安全对象池，将暂时用不到的对象放入池中，在后续使用中就不需要再额外的创建对象可以直接复用，减少内存的分配与释放频率，最重要的一点就是降低 GC 压力。

pool.New = func() any {

当使用完对象后，一定要释放回池中，如果用了不释放那么对象池的使用将毫无意义


CAS 相关的函数则需要传入地址，期望值，新值，且会返回是否成功替换的布尔值。


























